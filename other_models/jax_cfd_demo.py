# -*- coding: utf-8 -*-
"""JAX-CFD demo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/google/jax-cfd/blob/main/notebooks/demo.ipynb

# JAX-CFD demo

This initial demonstration shows how to use JAX-CFD to simulate decaying turbulence in 2D.
"""

import jax
import jax.numpy as jnp
import jax_cfd.base as cfd
import numpy as np
import seaborn
import xarray
import os
import time

# GPU settings
gpu_idx = 3
os.environ["CUDA_DEVICE_ORDER"] = "PCI_BUS_ID"  # GPU indexing
os.environ["CUDA_VISIBLE_DEVICES"] = str(gpu_idx)  # GPU indexing

# Commented out IPython magic to ensure Python compatibility.
size = 256
density = 1.
viscosity = 1e-3
seed = 0
inner_steps = 25
outer_steps = 200

max_velocity = 2.0
cfl_safety_factor = 0.5

# Define the physical dimensions of the simulation.
grid = cfd.grids.Grid((size, size), domain=((0, 2 * jnp.pi), (0, 2 * jnp.pi)))

# Construct a random initial velocity. The `filtered_velocity_field` function
# ensures that the initial velocity is divergence free and it filters out
# high frequency fluctuations.
v0 = cfd.initial_conditions.filtered_velocity_field(
    jax.random.PRNGKey(seed), grid, max_velocity)

# Choose a time step.
dt = cfd.equations.stable_time_step(
    max_velocity, cfl_safety_factor, viscosity, grid)

# Define a step function and use it to compute a trajectory.
step_fn = cfd.funcutils.repeated(
    cfd.equations.semi_implicit_navier_stokes(
        density=density, viscosity=viscosity, dt=dt, grid=grid),
    steps=inner_steps)
rollout_fn = jax.jit(cfd.funcutils.trajectory(step_fn, outer_steps))

start_time = time.time()
_, trajectory = jax.device_get(rollout_fn(v0))
print(f"Execution time: {time.time() - start_time:.2f} seconds")



u_traj = trajectory[0].data # (200, 256, 256)
v_traj = trajectory[1].data # (200, 256, 256)

# Extract spatial coordinates
x_coords, y_coords = jnp.meshgrid(grid.axes()[0], grid.axes()[1], indexing='ij') # (256, 256) each

# Create time array
time_steps = dt * inner_steps * np.arange(outer_steps) # (200,)

# Flatten all arrays
x_flat = x_coords.ravel() # (256*256,)
y_flat = y_coords.ravel() # (256*256,)
x_flat = np.tile(x_flat, outer_steps)
y_flat = np.tile(y_flat, outer_steps)
time_flat = np.repeat(time_steps, size * size)
u_flat = u_traj.reshape(outer_steps, -1).ravel()
v_flat = v_traj.reshape(outer_steps, -1).ravel()

# Concatenate into a single array
x_flat = x_flat.astype(np.float32)
y_flat = y_flat.astype(np.float32)
time_flat = time_flat.astype(np.float32)
u_flat = u_flat.astype(np.float32)
v_flat = v_flat.astype(np.float32)
data = np.column_stack((x_flat, y_flat, time_flat, u_flat, v_flat)) # (200*256*256, 5)

# Save the data array to a CSV file
output_file = "velocity_data.csv"
header = ["x", "y", "t", "u", "v"]
np.savetxt(output_file, data, delimiter=",", header=",".join(header), comments="")
print(f"Data saved to {output_file}")



############################# Create video ############################

import matplotlib.pyplot as plt
import matplotlib.animation as animation

# Reshape u and v trajectories for visualization
u_traj_reshaped = u_traj.reshape(outer_steps, size, size)
v_traj_reshaped = v_traj.reshape(outer_steps, size, size)

# Create a figure and axes for the animation
fig, (ax_u, ax_v) = plt.subplots(1, 2, figsize=(12, 6))
fig.suptitle("Time Evolution of u and v")

# Initialize the plots
u_plot = ax_u.imshow(u_traj_reshaped[0], origin='lower', extent=(0, 2 * jnp.pi, 0, 2 * jnp.pi), cmap='viridis')
v_plot = ax_v.imshow(v_traj_reshaped[0], origin='lower', extent=(0, 2 * jnp.pi, 0, 2 * jnp.pi), cmap='viridis')

ax_u.set_title("u velocity")
ax_v.set_title("v velocity")
ax_u.set_xlabel("x")
ax_u.set_ylabel("y")
ax_v.set_xlabel("x")
ax_v.set_ylabel("y")

# Add colorbars
fig.colorbar(u_plot, ax=ax_u)
fig.colorbar(v_plot, ax=ax_v)

# Update function for the animation
def update(frame):
    u_plot.set_data(u_traj_reshaped[frame])
    v_plot.set_data(v_traj_reshaped[frame])
    return u_plot, v_plot

# Create the animation
ani = animation.FuncAnimation(fig, update, frames=outer_steps, interval=50, blit=True)

# Save the animation as a video file
ani.save("velocity_evolution.gif", writer="ffmpeg", fps=20)

# Close the plot to avoid displaying it
plt.close(fig)

# JAX-CFD uses GridVariable objects for input/output. These objects contain:
#  - array data
#  - an "offset" that documents the position on the unit-cell where the data
#    values are located
#  - grid properties
#  - boundary conditions on the variable
# with np.printoptions(edgeitems=1):
#   for i, u in enumerate(trajectory):
#     print(f'Component {i}: {u}')

# # load into xarray for visualization and analysis
# ds = xarray.Dataset(
#     {
#         'u': (('time', 'x', 'y'), trajectory[0].data),
#         'v': (('time', 'x', 'y'), trajectory[1].data),
#     },
#     coords={
#         'x': grid.axes()[0],
#         'y': grid.axes()[1],
#         'time': dt * inner_steps * np.arange(outer_steps)
#     }
# )

# ds

# def vorticity(ds):
#   return (ds.v.differentiate('x') - ds.u.differentiate('y')).rename('vorticity')

# (ds.pipe(vorticity).thin(time=20)
#  .plot.imshow(col='time', cmap=seaborn.cm.icefire, robust=True, col_wrap=5))

